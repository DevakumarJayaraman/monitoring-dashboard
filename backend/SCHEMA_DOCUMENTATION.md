# Backend Database Schema - Aligned with context.MD

## Overview

The backend has been completely reworked to follow the **normalized database schema** specified in `context.MD` (lines 117+). This design separates concerns and follows proper database normalization principles.

## Database Schema

### 1. **ops_infra** - Infrastructure Master Table
Stores basic infrastructure information (VMs, ECS clusters, databases).

```sql
CREATE TABLE ops_infra (
    infra_id     NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    infra_name   VARCHAR2(255) NOT NULL,
    infra_type   VARCHAR2(50) NOT NULL,          -- ecs/linux/windows/dbaas
    hostname     VARCHAR2(255),
    ip_address   VARCHAR2(50),
    environment  VARCHAR2(50),                   -- DEV/UAT/PROD
    version      NUMBER(10) DEFAULT 0 NOT NULL   -- JPA @Version for optimistic locking
);
```

**Entity**: `Infrastructure.java`

---

### 2. **infra_resource_limits** - Resource Capacity Limits
Defines capacity limits for each infrastructure (CPU, memory, disk).

```sql
CREATE TABLE infra_resource_limits (
    limit_id      NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    infra_id      NUMBER NOT NULL REFERENCES ops_infra(infra_id),
    resource_name VARCHAR2(100) NOT NULL,        -- cpu, memory, disk
    limit_value   VARCHAR2(100) NOT NULL,
    unit          VARCHAR2(20),
    version       NUMBER(10) DEFAULT 0 NOT NULL
);
```

**Entity**: `InfraResourceLimit.java`
**Repository**: `InfraResourceLimitRepository.java`

---

### 3. **ops_infra_usage_metrics** - Time-Series Usage Data
Stores actual usage metrics over time for each infrastructure.

```sql
CREATE TABLE ops_infra_usage_metrics (
    metric_id     NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    infra_id      NUMBER NOT NULL REFERENCES ops_infra(infra_id),
    metric_name   VARCHAR2(100) NOT NULL,        -- cpu_usage_pct, disk_usage_pct, memory_usage_pct
    metric_value  VARCHAR2(100) NOT NULL,
    unit          VARCHAR2(20),
    metric_date   DATE NOT NULL,                 -- summary date (for daily aggregation)
    metric_time   DATE NOT NULL,                 -- exact timestamp (for real-time monitoring)
    version       NUMBER(10) DEFAULT 0 NOT NULL
);
```

**Entity**: `InfraUsageMetric.java`
**Repository**: `InfraUsageMetricRepository.java`

---

### 4. **ops_services** - Services Master Table
Catalog of all services/applications in the organization.

```sql
CREATE TABLE ops_services (
    service_id    NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    service_name  VARCHAR2(255) NOT NULL,
    description   VARCHAR2(2048),
    owning_team   VARCHAR2(100),
    version       NUMBER(10) DEFAULT 0 NOT NULL
);
```

**Entity**: `Service.java`
**Repository**: `ServiceRepository.java`

---

### 5. **ops_service_deployments** - Deployment Mappings
Maps which services are deployed on which infrastructure with which profile.

```sql
CREATE TABLE ops_service_deployments (
    mapping_id    NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    service_id    NUMBER NOT NULL REFERENCES ops_services(service_id),
    infra_id      NUMBER NOT NULL REFERENCES ops_infra(infra_id),
    profile       VARCHAR2(100) NOT NULL,        -- apacqa, apacuat, emeaprod, etc.
    port          NUMBER,
    version       NUMBER(10) DEFAULT 0 NOT NULL,
    CONSTRAINT uk_service_infra_profile UNIQUE (service_id, infra_id, profile)
);
```

**Entity**: `ServiceDeployment.java`
**Repository**: `ServiceDeploymentRepository.java`

**Key Constraint**: A service can only be deployed once on a specific infrastructure with a specific profile.

---

### 6. **ops_deployment_configs** - Per-Deployment Resource Configs
Defines resource allocation for each service deployment (can differ by profile/environment).

```sql
CREATE TABLE ops_deployment_configs (
    config_id     NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    service_id    NUMBER NOT NULL REFERENCES ops_services(service_id),
    infra_id      NUMBER REFERENCES ops_infra(infra_id),
    profile       VARCHAR2(100),
    resource_name VARCHAR2(100) NOT NULL,        -- cpu, memory, threads, heap_size
    limit_value   VARCHAR2(100) NOT NULL,
    unit          VARCHAR2(20),
    version       NUMBER(10) DEFAULT 0 NOT NULL,
    CONSTRAINT uk_service_infra_profile_resource 
        UNIQUE (service_id, infra_id, profile, resource_name)
);
```

**Entity**: `DeploymentConfig.java`
**Repository**: `DeploymentConfigRepository.java`

---

## Entity Relationships

```
ops_infra (1) ──< (N) infra_resource_limits
          (1) ──< (N) ops_infra_usage_metrics
          (1) ──< (N) ops_service_deployments

ops_services (1) ──< (N) ops_service_deployments
             (1) ──< (N) ops_deployment_configs

ops_service_deployments (M:N junction table between ops_services and ops_infra)
```

## Key Design Principles

### 1. **Separation of Static vs Dynamic Data**
- **Static**: Infrastructure definitions, service catalog, deployment mappings
- **Dynamic**: Usage metrics (time-series data)

### 2. **Flexible Resource Configuration**
- Infrastructure limits are stored as key-value pairs (resource_name, limit_value, unit)
- Allows adding new resource types without schema changes

### 3. **Profile-Based Deployments**
- Same service can be deployed multiple times on different infrastructure with different profiles
- Example: `payment-service` on `apacqa-vm1` with profile `apacqa`

### 4. **Optimistic Locking**
- All tables use `@Version` for JPA optimistic locking
- Prevents concurrent modification conflicts

### 5. **Time-Series Metrics**
- Separate table for metrics allows efficient time-series queries
- `metric_date` for daily aggregations
- `metric_time` for real-time tracking

## JPA Entities Created

| Entity | Table | Purpose |
|--------|-------|---------|
| `Infrastructure.java` | `ops_infra` | Infrastructure master |
| `InfraResourceLimit.java` | `infra_resource_limits` | Capacity limits |
| `InfraUsageMetric.java` | `ops_infra_usage_metrics` | Usage time-series |
| `Service.java` | `ops_services` | Service catalog |
| `ServiceDeployment.java` | `ops_service_deployments` | Service-Infra mappings |
| `DeploymentConfig.java` | `ops_deployment_configs` | Per-deployment configs |

## Spring Data JPA Repositories

| Repository | Key Methods |
|------------|-------------|
| `InfrastructureRepository` | `findByInfraName`, `findByInfraType`, `findByEnvironment` |
| `InfraResourceLimitRepository` | `findByInfrastructure_InfraId`, `findByResourceName` |
| `InfraUsageMetricRepository` | `findByInfrastructure_InfraId`, `findLatestMetricsForInfra` |
| `ServiceRepository` | `findByServiceName`, `findByOwningTeam` |
| `ServiceDeploymentRepository` | `findByInfrastructure_InfraId`, `findByService_ServiceId`, `findByProfile` |
| `DeploymentConfigRepository` | `findByService_ServiceId`, `findByServiceAndInfraAndProfile` |

## Example Usage Scenarios

### 1. Get all services running on a specific infrastructure
```java
List<ServiceDeployment> deployments = serviceDeploymentRepository
    .findByInfrastructure_InfraId(infraId);
```

### 2. Get CPU usage for an infrastructure on a specific date
```java
List<InfraUsageMetric> metrics = infraUsageMetricRepository
    .findLatestMetricsForInfra(infraId, LocalDate.now());
```

### 3. Get all resource limits for an infrastructure
```java
List<InfraResourceLimit> limits = infraResourceLimitRepository
    .findByInfrastructure_InfraId(infraId);
```

### 4. Check if a service is already deployed on infrastructure with a profile
```java
Optional<ServiceDeployment> existing = serviceDeploymentRepository
    .findByServiceAndInfraAndProfile(serviceId, infraId, "apacqa");
```

## Next Steps

1. **Create DTOs** for API responses (flatten the relationships for frontend)
2. **Create Service Layer** with business logic for CRUD operations
3. **Create Controllers** with REST endpoints
4. **Create Data Initializer** to seed sample data
5. **Update application.properties** for H2 database configuration
6. **Create API documentation** for frontend integration

## Benefits of This Design

✅ **Normalized** - No data duplication  
✅ **Flexible** - Easy to add new resource types  
✅ **Scalable** - Time-series metrics in separate table  
✅ **Maintainable** - Clear separation of concerns  
✅ **Type-safe** - Strong foreign key relationships  
✅ **Concurrent-safe** - Optimistic locking with @Version  
✅ **Query-efficient** - Proper indexing on foreign keys  

## Database Diagram

```
┌─────────────────┐
│   ops_infra     │
│  (infra_id)     │
└────┬────────────┘
     │
     ├─────────────────────────────┐
     │                             │
     ▼                             ▼
┌──────────────────────┐    ┌─────────────────────┐
│infra_resource_limits │    │ops_infra_usage      │
│    (limit_id)        │    │metrics (metric_id)  │
└──────────────────────┘    └─────────────────────┘
     
     
┌─────────────────┐         ┌──────────────────────┐
│  ops_services   │         │ops_service_deployments│
│  (service_id)   │◄────────│   (mapping_id)        │
└────┬────────────┘         └──────────┬───────────┘
     │                                  │
     │                                  │
     │                                  ▼
     │                          ┌─────────────────┐
     │                          │   ops_infra     │
     │                          │  (infra_id)     │
     │                          └─────────────────┘
     │
     ▼
┌──────────────────────┐
│ops_deployment_configs│
│    (config_id)       │
└──────────────────────┘
```

---

**File Location**: `/backend/SCHEMA_DOCUMENTATION.md`
**Created**: October 3, 2025
**Schema Source**: `context.MD` lines 117-205
